"""
Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are
generated by the following formulae:

Triangle     P3,n=n(n+1)/2      1, 3, 6, 10, 15, ...
Square       P4,n=n^2            1, 4, 9, 16, 25, ...
Pentagonal   P5,n=n(3n−1)/2     1, 5, 12, 22, 35, ...
Hexagonal    P6,n=n(2n−1)       1, 6, 15, 28, 45, ...
Heptagonal   P7,n=n(5n−3)/2     1, 7, 18, 34, 55, ...
Octagonal    P8,n=n(3n−2)       1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including
   the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a
   different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square,
pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
"""
import math

from problem42 import is_triangle_number as is_triangular
from problem44 import is_pentagonal
from problem45 import is_hexagonal


def is_square(n):
    return math.sqrt(n).is_integer()


def is_heptagonal(n):
    return ((3 + math.sqrt(9 + 40 * n)) / 10).is_integer()


def is_octagonal(n):
    return ((2 + math.sqrt(4 + 12 * n)) / 6).is_integer()


assert is_triangular(15)
assert is_square(25)
assert is_pentagonal(35)
assert is_hexagonal(45)
assert is_heptagonal(55)
assert is_octagonal(65)


def find_set():
    numbers = {
        3: [n for n in range(1000, 10000) if is_triangular(n) and not is_hexagonal(n)],
        4: [n for n in range(1000, 10000) if is_square(n)],
        5: [n for n in range(1000, 10000) if is_pentagonal(n)],
        6: [n for n in range(1000, 10000) if is_hexagonal(n)],
        7: [n for n in range(1000, 10000) if is_heptagonal(n)],
        8: [n for n in range(1000, 10000) if is_octagonal(n)]
    }
    types = {3, 4, 5, 6, 7}
    for n1 in numbers[8]:
        for t2 in types:
            c2 = [n for n in numbers[t2] if n // 100 == n1 % 100]
            for n2 in c2:
                for t3 in types - {t2}:
                    c3 = [n for n in numbers[t3] if n // 100 == n2 % 100]
                    for n3 in c3:
                        for t4 in types - {t2, t3}:
                            c4 = [n for n in numbers[t4] if n // 100 == n3 % 100]
                            for n4 in c4:
                                for t5 in types - {t2, t3, t4}:
                                    c5 = [n for n in numbers[t5] if n // 100 == n4 % 100]
                                    for n5 in c5:
                                        n6 = 100 * (n5 % 100) + n1 // 100
                                        t6 = (types - {t2, t3, t4, t5}).pop()
                                        if n6 not in numbers[t6]:
                                            continue
                                        segments = {n % 100 for n in (n1, n2, n3, n4, n5, n6)}
                                        if min(segments) >= 10 and len(segments) == 6:
                                            return n1 + n2 + n3 + n4 + n5 + n6
if __name__ == '__main__':
    print(find_set())
